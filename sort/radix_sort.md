# 基数排序

- [基数排序](#基数排序)
  - [简介](#简介)
  - [基数排序，计数排序和桶排序](#基数排序计数排序和桶排序)
  - [性能](#性能)
  - [LSD 排序](#lsd-排序)
  - [MSD 排序](#msd-排序)

2021-05-28, 09:35
@Jiawei Mao
***

## 简介

基数排序（radix sort）是一种非比较型的整数排序算法。其原理

基数的“基”可以将其理解为进制，对2进制数，从右向左，基分别为 $2^0$,$2^1$...。在对人名进行排序的时候很自然会使用它，对所有的大写字母，此时的基为26，对应26个字母。

其原理是将整数按位数进行划分，然后对每个位数分别比较。由于整数也可以用来表示字符串和特定格式的浮点数，所以基数排序不限于整数排序。

由于计算机内部采用二进制存储数据，所以通过整数的二进制表示对数据进行数据处理最方便。基数排序可以分为低位 _LSD (Least significant digital)_ 和高位 _MSD (Most significant digital)_ 两类，LSD 从最小位开始对整数进行处理，MSD相反。例如对数 1234，可以从1 或 4 开始。

LSD 基数排序采用以下顺序：短的排在前面，相同的长度的按照字典顺序排序。这 _和常规的整数排序一样_，如 `1, 2, 3, 4, 5, 6, 7, 8, 9, 10`，其中 `10` 最长，所以放在最后，`1-9` 长度一致，按字段顺序排列。对三位数的排序，如下所示：

|INPUT|1st pass|2nd pass|3rd pass|
|---|---|---|---|
|329|720|720|329|
|457|355|329|355|
|657|436|436|436|
|839|457|839|457|
|436|657|355|657|
|720|329|457|720|
|355|839|657|839|

MSD 基数排序采用字典顺序，适合于 _字符串和长度固定的整数_ 的排序。如 `b, c, d, e, f, g, h, i, j, ba` 按字典顺序排序为 `b, ba, c, d, e, f, g, h, i, j`。固定长度的整数，从最高位开始比较，每一位的位数都相同，所以用MSD比较没问题；如果整数的长度不固定，如 1 到 10，按MSD排序就存在问题。

可以认为 LSD 为右对齐，左边位数不足以0补齐；MSD 为左对齐，右边位数不足以 0 补。

## 基数排序，计数排序和桶排序

这三种排序算法都利用了桶的概念，但在使用方法上有差异：

- 基数排序：根据键值的每位数字来分配桶
- 计数排序：每个桶只存储单一键值；
- 桶排序：每个桶存储一定范围的数值。

## 性能

相比与其它排序算法，基数排序的性能不是很好确定，而且很容易误解。基数排序的性能取决于具体实现，其效率为 $O(d\cdot n)$，其中 d 为数字的位数，n 为排序元素个数。当 d 为常量，基数排序比最好的对比排序（需要 $O(nlogn)$次对比）都要好（n 足够大）。

不过，d 往往不能简单当作一个常量来处理。比如，当所有排序元素都不相同，则 d 最小为 log(n)，此时最好的时间复杂度是 $O(n\cdot log(n))$。从而使基数排序的效率和最好的对比排序效率相当(如果d大于log(n)，其效率比对比排序更低)。

也有持反对观点的，他们认为对比排序算法的复杂度是以对比的数目衡量的，并非实际的时间复杂度。对比所花时间可能为常量，当然也可能不是。其中，随机生成数平均对比时间为常量，根据第一位就可以区分一半的数，根据第二位又可以区分一半，以此类推，最后需要对比的平均位数为2。对一个排序算法，第一次对比满足随机条件，但随着排序进行，后面的待对比元素明显不再是随机的。

其中的关键因素是待排序元素的分布。

## LSD 排序

最低有效位基数排序(Least significant digit radix sorts, LSD)可用于以整数表示的元素的快速稳定排序。元素可以是字符串或者指定“基数”的数值。键值从低位(最右边数字)向高位(最左边数字)处理。以LSD处理的序列和以MSD处理的序列完全相反。

LSD基数排序时间复杂度为O(nk)，n为待排序元素个数，k为平均元素长度。

LSD 动画演示：

![](images/radixSort.gif)

## MSD 排序
